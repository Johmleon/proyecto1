COMANDOS DE GIT:

git comando --help : muestra detalles de los comandos.

pwd: indica en que carpeta se encuentra

git init: iniciar git en una carpeta.

git config -l : ver configuraciones en lista.

git config --global user.email "email" : cambiar email de usuario.

git add para añadir el archivo a la carpeta.

git commit -m "comentario" para subir el archivo al repo.
cuando haces un commit y no le pones comentario, te salta una ventana, donde te sugiere que
le coloques un mensaje, para salir de esa venta tienes que pulsar
esc + shift + z + z.

git commit -am "Mensaje del commit" : se utiliza solo con archivos a los cuales ya se les 
ha hecho git add anteriormente.

git show para mostrar cambios.

git log para mostrar registro.

git diff a + b para comparar cambios.

git log --stat se usa para mostrar exactamente los cambios realizados.
pulsa Q para salir.

git reset se utiliza para volver al pasado pero sin la posibilidad de ir al futuro nuevamente
git reset --hard
git reset --soft
git reser HEAD: se utiliza para sacar archivos de staging

Como volver a una version anterior:
git checkout + commit del archivo + nombre del archivo: se utiliza para ver como era el archivo
para volver a la version que se tenia se tiene que colocar 
git checkout master + nombre del archivo.

git rm eliminar archivos sin eliminar su historial, se puede recuperar.
git rm --cached: elimina de local y de staging
git rm --force: elimina de local y de disco duro

Comandos para trabajo remoto con GIT:

git remote add origin + url del repositorio Github : añadimos repo remoto.
git remote add origin git@github.com:tu_usuario/nombre_del_repositorio.git (este fue el que me funciono)

git pull origin master: para subir al remoto.

git pull origin master --allow-unrelated-histories : caso muy particular pero ahi esta la solucion al error.

git remote remove origin: para eliminar url del remoto. 

git remote : para verificar que se haya subido el repositorio, te muestra origin.

git remote -v 
te da como resultado dos origin un fetch para traer cosas y un push para enviar cosas.

git push origin master (o main): enviar al origin la rama master.

git clone url_del_servidor_remoto: Nos permite descargar los archivos de la última versión 
de la rama principal y todo el historial de cambios en la carpeta .git.

git push: Luego de hacer git add y git commit debemos ejecutar este comando para 
mandar los cambios al servidor remoto.

git fetch: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro 
repositorio local (en caso de que hayan, por supuesto).

git merge: También usamos el comando git merge con servidores remotos. 
Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro 
directorio de trabajo.

Si en las dos ramas se hicieron cambios sobre la misma linea,
git arroja un error y no deja hacer el merge.

git merge --abort: se utiliza para revertir un merge.

git pull: Básicamente, git fetch y git merge al mismo tiempo.

Comandos para trabajar con ramas:

git branch -nombre de la rama-: Con este comando se genera una nueva rama.

git checkout -nombre de la rama-: Con este comando puedes saltar de una rama a otra.

git checkout -b rama: Genera una rama y nos mueve a ella automáticamente, Es decir, es la combinación de git branch y git checkout al mismo tiempo.

git reset id-commit: Nos lleva a cualquier commit no importa la rama, ya que identificamos el id del tag., eliminando el historial de los commit posteriores al tag seleccionado.

git checkout rama-o-id-commit: Nos lleva a cualquier commit sin borrar los commit posteriores al tag seleccionado.

Crear llaves SSH:

Es necesario estar en el home de GIT

ssh-keygen -t rsa -b 4096(complejidad de la llave) -C "email" : se usa para crear una llave

preferiblemente guardar en la misma carpeta que recomienda
colocar passphrase
te da una fingerprint y una randomart.

verificar que el servicio de llaves esté corriendo (Windows y Linux):

eval $(ssh-agent -s)
saldra un pid con un codigo

agregar la llave a nuestro sistema:

recordar ruta de la carpeta
usar ~ para ir al directorio users

ssh-add ~/ .ssh/id_rsa

git log --all --graph --decorate --oneline  : mostrar toda la informacion reducida.

$ alias ordenado="git log --all --graph --decorate --oneline" :
agregamos un alias a un comando muy largo para luego llamarlo facilmente con el nombre.

añadimos tag o nombre de version a un commit:
git tag -a "v0.1" -m "Resultado de las primeras clases del curso" a85d07b (tag del commit reducido).

verificamos los tags:
git show-ref --tags

Crear un nuevo tag y asignarlo a un commit: git tag -a nombre-del-tag id-del-commit.
Borrar un tag en el repositorio local: git tag -d nombre-del-tag.
Listar los tags de nuestro repositorio local: git tag o git show-ref --tags.
Publicar un tag en el repositorio remoto: git push origin --tags.
Borrar un tag del repositorio remoto: git tag -d nombre-del-tag y git push origin :refs/tags/nombre-del-tag.

Crear una rama:
git branch branchName
Movernos a otra rama:
git checkout branchName
Crear una rama en el repositorio local:
git branch nombre-de-la-rama o git checkout -b nombre-de-la-rama.
Publicar una rama local al repositorio remoto:
git push origin nombre-de-la-rama.

git show-branch : muestra las ramas existentes.
git show-branch --all : muestra todos los datos de la rama.

gitk : muestra un entorno grafico de las branch y sus modificaciones.
Si no te funciona el comando gitk es posible no lo tengas instalado por defecto.
Para instalar gitk debemos ejecutar los siguientes comandos:
sudo apt-get update
sudo apt-get install gitk

Fork

hacer un fork es tomar una copia del estado actual de un proyecto y clonarlo.


Cómo se hace un fork remoto desde consola en GitHub
Al hacer un fork, GitHub sabe que se hizo el fork del proyecto, por lo que se le permite al colaborador hacer pull request desde su repositorio propio.

Cuando trabajas en un proyecto que existe en diferentes repositorios remotos (normalmente a causa de un fork), es muy probable que desees poder trabajar con ambos repositorios. Para esto, puedes generar un remoto adicional desde consola.

git remote add <nombre_del_remoto> <url_del_remoto> 
git remote upstream https://github.com/freddier/hyperblog
Al crear un remoto adicional, podremos hacer pull desde el nuevo origen. En caso de tener permisos, podremos hacer fetch y push.

git pull <remoto> <rama>
git pull upstream master
Este pull nos traerá los cambios del remoto, por lo que se estará al día en el proyecto. El flujo de trabajo cambia, en adelante se estará trabajando haciendo pull desde el upstream y push al origin para pasar a hacer pull request.

git pull upstream master
git push origin master

GIT ignore

Por diversas razones, no todos los archivos que agregas a un proyecto deberían guardarse en un repositorio, ésto porque 
hay archivos que no todo el mundo debería de ver, y hay archivos que al estar en el repositorio alentan 
el proceso de desarrollo (por ejemplo los binary large objects, blob, que se tardan en descargarse).

Para que no se suban estos archivos no deseados se puede crear un archivo con el 
nombre .gitignore en la raíz del repositorio con las reglas para los archivos que no se deberían 
subir (ver sintaxis de los .gitignore(https://git-scm.com/docs/gitignore)).

Las razones principales para tomar la decisión de no agregar un archivo a un repositorio son:

Es un archivo con contraseñas (normalmente con la extensión .env)
Es un blob (binary large object, objeto binario grande), mismos que son difíciles de gestionar en git.
Son archivos que se generan corriendo comandos, por ejemplo la carpeta node_modules que genera npm al correr el comando npm install

README.mod

basado en lenguaje markdown
se utiliza para la presentacion del repositorio, mejora su imagen.

Github Pages

GitHub tiene un servicio de hosting gratis llamado GitHub Pages. Con él, puedes tener un repositorio alojado en GitHub y hacer que el contenido se muestre en la web en tiempo real.

Este es un sitio para nuestros proyectos donde lo único que tenemos que hacer es tener un repositorio alojado. En la página, podemos seguir las instrucciones para crear este repositorio

Pasos para subir un repositorio a GitHub Pages
Debemos tomar la llave SSH y hacer un git clone #SSHexample en mi computador local (Home).
Luego, accederemos a la carpeta nueva que aparece en nuestra máquina local.
Creamos un nuevo archivo que se llame index.html
Guardamos los cambios, hacemos un git pull y seguido de esto un git push a master.
Vamos a las opciones de settings de este repositorio y, en la parte de abajo, en la columna Github Pages, configuramos el source o fuente para que traiga la rama master
Guardamos los cambios.

Después de esto, podremos ver nuestro trabajo en la web como si tuviéramos nuestro propio servidor.

para que te lo reconozca desde la raiz, tenemos que colocar el url al nombre, ejemplo:

nombre del repositorio
johmleon.github.io
luego de eso ya estaria cargando la raiz como una pagina nueva.

GIT REBASE

*mala practica*
reescribe la historia del repositorio, cambia la historia de donde comenzó la rama
y solo debe ser usado de manera local. 
git checkout + nombre de la rama la cual se va a reescribir
git rebase master
listo, con esto estariamos añadiendo la historia de la rama modificada al master.
no es muy recomendable su uso ya que es considerado una mala practica.

GIT STASH

El stashed nos sirve para guardar cambios para después, Es una lista de estados que nos guarda algunos cambios que hicimos en Staging para poder cambiar de rama o branch sin perder el trabajo que todavía no guardamos en un commit

Ésto es especialmente útil porque hay veces que no se permite cambiar de rama, ésto porque tenemos cambios sin guardar, no siempre es un cambio lo suficientemente bueno como para hacer un commit, pero no queremos perder ese código en el que estuvimos trabajando.

El stashed nos permite cambiar de ramas, hacer cambios, trabajar en otras cosas y, más adelante, retomar el trabajo con los archivos que teníamos en Staging, pero que podemos recuperar, ya que los guardamos en el Stash.

git stash
El comando git stash guarda el trabajo actual del Staging en una lista diseñada para ser temporal llamada Stash, para que pueda ser recuperado en el futuro.

Para agregar los cambios al stash se utiliza el comando:

git stash

Podemos poner un mensaje en el stash, para asi diferenciarlos en git stash list por si tenemos varios elementos en el stash. Ésto con:

git stash save "mensaje identificador del elemento del stashed"

Obtener elelmentos del stash
El stashed se comporta como una Stack de datos comportándose de manera tipo LIFO (del inglés Last In, First Out, «último en entrar, primero en salir»), así podemos acceder al método pop.

El método pop recuperará y sacará de la lista el último estado del stashed y lo insertará en el staging area, por lo que es importante saber en qué branch te encuentras para poder recuperarlo, ya que el stash será agnóstico a la rama o estado en el que te encuentres. Siempre recuperará los cambios que hiciste en el lugar que lo llamas.

Para recuperar los últimos cambios desde el stash a tu staging area utiliza el comando:

git stash pop

Para aplicar los cambios de un stash específico y eliminarlo del stash:

git stash pop stash@{<num_stash>}

Para retomar los cambios de una posición específica del Stash puedes utilizar el comando:

git stash apply stash@{<num_stash>}

Donde el <num_stash> lo obtienes desden el git stash list

Listado de elementos en el stash
Para ver la lista de cambios guardados en Stash y así poder recuperarlos o hacer algo con ellos podemos utilizar el comando:

git stash list

Retomar los cambios de una posición específica del Stash || Aplica los cambios de un stash específico

Crear una rama con el stash
Para crear una rama y aplicar el stash más reciente podemos utilizar el comando

git stash branch <nombre_de_la_rama>

Si deseas crear una rama y aplicar un stash específico (obtenido desde git stash list) puedes utilizar el comando:

git stash branch nombre_de_rama stash@{<num_stash>}

Al utilizar estos comandos crearás una rama con el nombre <nombre_de_la_rama>, te pasarás a ella y tendrás el stash especificado en tu staging area.

Eliminar elementos del stash
Para eliminar los cambios más recientes dentro del stash (el elemento 0), podemos utilizar el comando:

git stash drop

Pero si, en cambio, conoces el índice del stash que quieres borrar (mediante git stash list) puedes utilizar el comando:

git stash drop stash@{<num_stash>}

Donde el <num_stash> es el índice del cambio guardado.

Si, en cambio, deseas eliminar todos los elementos del stash, puedes utilizar:

git stash clear

Consideraciones:
El cambio más reciente (al crear un stash) SIEMPRE recibe el valor 0 y los que estaban antes aumentan su valor.
Al crear un stash tomará los archivos que han sido modificados y eliminados. Para que tome un archivo creado es necesario 
agregarlo al Staging Area con git add [nombre_archivo] con la intención de que git tenga un seguimiento de ese archivo, 
o también utilizando el comando git stash -u (que guardará en el stash los archivos que no estén en el staging).
Al aplicar un stash este no se elimina, es buena práctica eliminarlo.

Limpiar proyecto

El parametro -d ayuda con el borrado de carpetas untracked.

GIT clean

El comando clean actúa en archivos sin seguimiento, este tipo de archivos son aquellos que se encuentran en el directorio de trabajo, 
pero que aún no se han añadido al índice de seguimiento de repositorio con el comando add.

$ git clean --dry-run 
se usa para revisar cuales archivos no tienen seguimiento.

$ git clean -f
elimina los archivos listados que no tienen seguimiento.

GIT Cherry-pick

Git Cherry-pick es un comando que permite tomar uno o varios commits de otra rama o branch sin tener que hacer un merge completo.
Así, gracias a cherry-pick, podríamos aplicar los commits relacionados con nuestra
funcionalidad en la rama master sin necesidad de hacer un merge.

El uso de git cherry-pick es sencillo y se puede ejecutar de la siguiente manera:

git cherry-pick #commit

git checkoutmaster
En este ejemplo, commitSha es una referencia de confirmación. Puedes encontrar una referencia de confirmación utilizando el comando git log. 
En este caso, imaginemos que queremos utilizar la confirmación ‘f’ en la rama master. 
Para ello, primero debemos asegurarnos de que estamos trabajando con esa rama master.
git cherry-pick f

Cherry-pick es una mala práctica porque significa que estamos reconstruyendo la historia, usa cherry-pick con sabiduría.
Si no sabes lo que estás haciendo, mejor evita emplear este comando.

Comandos GIT para casos de emergencia

GIT Reflog

Git guarda todos los cambios aunque decidas borrarlos, al borrar un cambio lo que estás haciendo sólo es actualizar 
la punta del branch, para gestionar éstas puntas existe un mecanismo llamado registros de referencia o reflogs
La gestión de estos cambios es mediante los hash’es de referencia (o ref) que son apuntadores a los commits
Los recoges registran cuándo se actualizaron las referencias de Git en el repositorio local (sólo en el local),
por lo que si deseas ver cómo has modificado la historia puedes utilizar el comando:

git reflog

GIT RESET

git reset: Hará que el último commit sea el pasado por la ref, usar este comando sólo si sabes exactamente qué estás haciendo

git reset --hard
git reset --soft
git reser HEAD: se utiliza para sacar archivos de staging

git reset es una mala práctica, no deberías usarlo en ningún momento. Debe ser nuestro último recurso.

Remendar un commit con amend puede modificar el commit más reciente (enmendar) en la misma rama. Lo ejecutamos así:

git add -A # Para hacer uso de amend los archivos deben de estar en staging
git commit --amend # Remendar último commit

GIT AMEND

Este comando sirve para agregar archivos nuevos o actualizar el commit anterior y no generar commits innecesarios.
También es una forma sencilla de editar o agregar comentarios al commit anterior porque abrirá la consola para editar este commit anterior.
Usar amend es una mala práctica, sobre todo cuando ya se ha hecho push o pull al repositorio remoto. 
Al momento de hacer amend con algún commit que esté en remoto, va a generar un conflicto que se va a arreglar 
haciendo un commit adicional y se perderá el beneficio del amend.

Buscar archivos y commits

Para buscar, empleamos el comando git grep color y nos buscará en todo el proyecto los archivos en donde está la palabra color.

git grep -n color nos saldrá un output el cual nos dirá en qué línea está lo que estamos buscando.
Con git grep -c color nos saldrá un output el cual nos dirá cuántas veces se repite esa palabra y en qué archivo.
Si queremos buscar cuántas veces utilizamos un atributo de HTML lo hacemos con git grep -c "<p>".

A continuación veremos una lista de comandos colaborativos para facilitar el trabajo remoto en GitHub:

git shortlog -sn: muestra cuantos commit han hecho cada miembro del equipo.
git shortlog -sn --all: muestra cuantos commit han hecho cada miembro del equipo, hasta los que han sido eliminados.
git shortlog -sn --all --no-merge: muestra cuantos commit ha hecho cada miembro, quitando los eliminados sin los merges.
git blame ARCHIVO: muestra quien hizo cada cosa línea por línea.
git COMANDO --help:muestra como funciona el comando.
git blame ARCHIVO -Llinea_inicial,linea_final: muestra quien hizo cada cosa línea por línea, indicándole desde qué línea ver. Ejemplo -L35,50.
git branch -r: se muestran todas las ramas remotas.
git branch -a: se muestran todas las ramas, tanto locales como remotas.